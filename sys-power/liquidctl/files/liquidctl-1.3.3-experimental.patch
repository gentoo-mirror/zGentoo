diff -Naur a/CHANGELOG.md b/CHANGELOG.md
--- a/CHANGELOG.md	2020-05-10 20:38:15.786948208 +0200
+++ b/CHANGELOG.md	2020-05-10 18:07:16.326085532 +0200
@@ -5,6 +5,20 @@
 The format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/) and this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html) and [PEP 404](https://www.python.org/dev/peps/pep-0440/#semantic-versioning).
 
 
+## [Unreleased]
+
+Changelog since 1.3.3:
+### Added
+ - List **experimental support for the NZXT RGB & Fan Controller**
+ - Add support for HSV, HSL and explicit RGB color representations
+ - [extra] Add initial generalized script for dynamic pump & fan control
+### Changed
+ - [Kraken X42/X52/X62/X72] Increase resolution of fan and pump profiles
+ - [extra/krakencurve-poc] Refresh syntax and sensor names; get CPU temperature on macOS with iStats
+ - Dynamically find the HID interface and endpoints of PyUsbHids
+ - Improve the documentation
+
+
 ## [1.3.3] – 2020-02-18
 _Summary for the 1.3.3 release: fix possibly stale data with HIDs and other minor issues._
 
@@ -13,6 +27,11 @@
  - [HUE 2] Add missing identifiers for HUE+ accessories
  - Forward hid option from UsbHidDriver.find_supported_devices
  - Prevent reporting stale data during long lived connections to HIDs (#87)
+### Checksums
+```
+1422a892f9c2c69f5949cd831083c6fef8f6a1f6e3215e90b696bfcd557924b4  liquidctl-1.3.3-bin-windows-x86_64.zip
+d13180867e07420c5890fe1110e8f45fe343794549a9ed7d5e8e76663bc10c24  liquidctl-1.3.3.tar.gz
+```
 
 
 ## [1.3.2] – 2019-12-11
diff -Naur a/docs/asetek-690lc.md b/docs/asetek-690lc.md
--- a/docs/asetek-690lc.md	2020-05-10 20:38:15.786948208 +0200
+++ b/docs/asetek-690lc.md	2020-05-10 18:05:13.885080747 +0200
@@ -9,7 +9,7 @@
  - Legacy designs:
     * NZXT Kraken X40, X60, X31, X41, X51 and X61
 
-**Note: a different kernel driver is necessary on Windows (see: [Additional requirements on Windows](https://github.com/jonasmalacofilho/liquidctl#additional-requirements-on-windows)).**
+**Note: a different kernel driver is necessary on Windows (see: [Installing on Windows](https://github.com/jonasmalacofilho/liquidctl#installing-on-windows)).**
 
 **Note: when dealing with legacy Krakens the `--legacy-690lc` flag should be supplied on all invocations of liquidctl.**
 
@@ -36,7 +36,7 @@
 
 ## Fan and pump speed control
 
-Fan speeds can be configured either by fixed duty values or (temperature, duty) profiles.  The profiles accept up to six points, and are interpolated by the device.
+Fan speeds can be configured either to fixed duty values or profiles.  The profiles accept up to six (liquid temperature, duty) points, and are interpolated by the device.
 
 ```
 # liquidctl set fan speed 50
diff -Naur a/docs/nzxt-kraken-x3-devices.md b/docs/nzxt-kraken-x3-devices.md
--- a/docs/nzxt-kraken-x3-devices.md	1970-01-01 01:00:00.000000000 +0100
+++ b/docs/nzxt-kraken-x3-devices.md	2020-05-10 18:07:16.326085532 +0200
@@ -0,0 +1,99 @@
+# NZXT X3 devices
+
+## NZXT Kraken X53, X63, X73
+
+The Kraken X53, X63 and X73 compose the fourth generation of liquid coolers by NZXT.  These devices are manufactured by Asetek and house seventh generation Asetek pumps, plus secondary PCBs specially designed by NZXT for enhanced control and lighting.
+
+They incorporate customizable pump speed control, a liquid temperature probe in the block and addressable RGB lighting.  The coolers are powered directly by the power supply unit.
+
+All configuration is done through USB, and persists as long as the device still gets power, even if the system has gone to Soft Off (S5) state.  The cooler also reports pump speed and liquid temperature via USB; pump speed can also be sent to the motherboard (or other device) via the sense pin of a standard fan connector.
+
+All capabilities available at the hardware level are supported, but other features offered by CAM, like presets based on CPU or GPU temperatures, have not been implemented.
+
+
+## Monitoring
+
+The cooler can report the pump speed and liquid temperature.
+
+```
+# liquidctl status
+NZXT Kraken X3 Pump (X53, X63 or X73) (experimental)
+├── Liquid temperature    24.1  °C
+├── Pump speed            1869  rpm
+└── Pump duty               60  %
+```
+
+
+## Pump speeds
+
+First, some important notes...
+
+*You must carefully consider what pump and fan speeds to run.  Heat output, case airflow, radiator size, installed fans and ambient temperature are some of the factors to take into account.  Test your settings under different scenarios, and make sure that they are appropriate, correctly applied and persistent.*
+
+*The X3 devices do not provide a way to control your fan speeds! Please set those fan curves wherever you plugged your fans in (e.g. motherboard).*
+
+*Additionally, the liquid temperature should never reach 60°C, as at that point the pump and tubes might fail or quickly degrade.  You must monitor this during your tests and make any necessary adjustments.  As a safety measure, pump speed will forcibly be programmed to 100% for liquid temperatures of 60°C and above.*
+
+*You should also consider monitoring your hardware temperatures and setting alerts for overheating components or pump failures.*
+
+With those out of the way, the pump speed can be configured to a fixed duty value or with a profile dependent on the liquid temperature.  Fixed speeds can be set by specifying the channel `pump` and duty.
+
+
+```
+# liquidctl set pump speed 90
+```
+
+| Channel | Minimum duty | Maximum duty |
+| --- | --- | --- |
+| pump | 20% | 100% |
+
+For profiles, one or more temperature–duty pairs must be supplied.  Liquidctl will normalize and optimize this profile before pushing it to the Kraken.  Adding `--verbose` will trace the final profile that is being applied.
+
+```
+# liquidctl set pump speed  20 30  30 50  34 80  40 90  50 100
+```
+
+
+## RGB lighting
+
+For lighting, the user can control a total of nine LEDs: one behind the NZXT logo and eight forming the ring that surrounds it.  These are separated into two channels, independently accessed through `logo` and `ring`.
+
+```
+# liquidctl set logo color fixed af5a2f
+# liquidctl set ring color fading 350017 ff2608
+# liquidctl set logo color pulse ffffff
+# liquidctl set ring color backwards-marquee-5 2f6017 --speed slower
+```
+
+Colors can be specified in RGB, HSV or HSL (see [Supported color specification formats](../README.md#supported-color-specification-formats)), and each animation mode supports different number of colors.  The animation speed can be customized with the `--speed <value>`, and five relative values are accepted by the device: `slowest`, `slower`, `normal`, `faster` and `fastest`.
+
+| `ring` | `logo` | Mode | Colors | Speed | Notes |
+| :---: | :---: | --- | --- | :---: | --- |
+| ✓ | ✓ | `off` | None | | 
+| ✓ | ✓ | `fixed` | One | |
+| ✓ | ✓ | `fading` | Between 1 and 8 | ✓ | |
+| ✓ | ✓ | `super-fixed` | Between 1 and 8 | | |
+| ✓ | ✓ | `spectrum-wave` | None | ✓ | |
+| ✓ | ✓ | `backwards-spectrum-wave` | None | ✓ | |
+| ✓ | ✓ | `marquee-<length>` | One | ✓ | 3 ≤ `length` ≤ 6 | 
+| ✓ | ✓ | `backwards-marquee-<length>` | One | ✓ | 3 ≤ `length` ≤ 6 |
+| ✓ | ✓ | `covering-marquee` | Between 1 and 8 | ✓ | |
+| ✓ | ✓ | `covering-backwards-marquee` | Between 1 and 8 | ✓ | |
+| ✓ | ✓ | `alternating-<length>` | Between 1 and 2 | ✓ | |
+| ✓ | ✓ | `moving-alternating-<length>` | Between 1 and 2 | ✓ | 3 ≤ `length` ≤ 6 |
+| ✓ | ✓ | `backwards-moving-alternating-<length>` | Between 1 and 2 | ✓ | 3 ≤ `length` ≤ 6 |
+| ✓ | ✓ | `pulse` | Between 1 and 8 | ✓ | |
+| ✓ | ✓ | `breathing` | Between 1 and 8 | ✓ | |
+| ✓ | ✓ | `super-breathing` | Between 1 and 8 | ✓ | |
+| ✓ | ✓ | `candle` | One | | |
+| ✓ | ✓ | `starry-night` | One | ✓ | |
+| ✓ | ✓ | `rainbow-flow` | None | ✓ | |
+| ✓ | ✓ | `super-rainbow` | None | ✓ | |
+| ✓ | ✓ | `rainbow-pulse` | None | ✓ | |
+| ✓ | ✓ | `backwards-rainbow-flow` | None | ✓ | |
+| ✓ | ✓ | `backwards-super-rainbow` | None | ✓ | |
+| ✓ | ✓ | `backwards-rainbow-pulse` | None | ✓ | |
+| ✓ | ✓ | `loading` | One | | |
+| ✓ | ✓ | `tai-chi` | Between 1 and 2 | ✓ | |
+| ✓ | ✓ | `water-cooler` | Two | ✓ | |
+| ✓ | ✓ | `wings` | One | ✓ | |
diff -Naur a/docs/nzxt-kraken-x-3rd-generation.md b/docs/nzxt-kraken-x-3rd-generation.md
--- a/docs/nzxt-kraken-x-3rd-generation.md	2020-05-10 20:38:15.786948208 +0200
+++ b/docs/nzxt-kraken-x-3rd-generation.md	2020-05-10 18:05:13.885080747 +0200
@@ -72,7 +72,7 @@
 # liquidctl set ring color backwards-marquee-5 2f6017 --speed slower
 ```
 
-Colors are set in hexadecimal RGB, and each animation mode supports different number of colors.  The animation speed can be customized with the `--speed <value>`, and five relative values are accepted by the device: `slowest`, `slower`, `normal`, `faster` and `fastest`.
+Colors can be specified in RGB, HSV or HSL (see [Supported color specification formats](../README.md#supported-color-specification-formats)), and each animation mode supports different number of colors.  The animation speed can be customized with the `--speed <value>`, and five relative values are accepted by the device: `slowest`, `slower`, `normal`, `faster` and `fastest`.
 
 | `ring` | `logo` | `sync` | Mode | Colors | Notes |
 | --- | --- | --- | --- | --- | --- |
diff -Naur a/docs/nzxt-smart-device.md b/docs/nzxt-smart-device.md
--- a/docs/nzxt-smart-device.md	2020-05-10 20:38:15.786948208 +0200
+++ b/docs/nzxt-smart-device.md	2020-05-10 18:05:13.885080747 +0200
@@ -85,7 +85,7 @@
 # liquidctl set led color backwards-marquee-5 2f6017 --speed slowest
 ```
 
-Colors are set in hexadecimal RGB, and each animation mode supports different number of colors.  The animation speed can be customized with the `--speed <value>`, and five relative values are accepted by the device: `slowest`, `slower`, `normal`, `faster` and `fastest`.
+Colors can be specified in RGB, HSV or HSL (see [Supported color specification formats](../README.md#supported-color-specification-formats)), and each animation mode supports different number of colors.  The animation speed can be customized with the `--speed <value>`, and five relative values are accepted by the device: `slowest`, `slower`, `normal`, `faster` and `fastest`.
 
 | Mode | Colors | Notes |
 | --- | --- | --- |
diff -Naur a/docs/nzxt-smart-device-v2.md b/docs/nzxt-smart-device-v2.md
--- a/docs/nzxt-smart-device-v2.md	2020-05-10 20:38:15.786948208 +0200
+++ b/docs/nzxt-smart-device-v2.md	2020-05-10 18:05:13.885080747 +0200
@@ -1,4 +1,4 @@
-# HUE 2, HUE 2 Ambient and Smart Device V2
+# NZXT HUE 2 and Smart Device V2 variants
 
 The NZXT HUE 2 lighting system is a refresh of the original HUE+.  The main improvement is the ability to mix Aer RGB 2 fans and HUE 2 lighting accessories (e.g. HUE 2 LED strip, HUE 2 Underglow, HUE 2 Cable Comb) in a channel.  HUE+ devices, including the original Aer RGB fans, are also supported, but HUE 2 components cannot be mixed with HUE+ components in the same channel.
 
@@ -26,6 +26,11 @@
 A microphone is still present onboard for noise level optimization through CAM and AI.
 
 
+## NZXT RGB & Fan Controller
+
+The NZXT RGB & Fan Controller is a retail version of the NZXT Smart Device V2.
+
+
 ## Initialization
 
 After powering on from Mechanical Off, or if there have been hardware changes, the device must first be initialized.  Only then monitoring, proper fan control and all lighting effects will be available.  The firmware version and the connected LED accessories are also reported during device initialization.
@@ -88,7 +93,7 @@
 # liquidctl set led4 color backwards-marquee-5 2f6017 --speed slowest
 ```
 
-Colors are set in hexadecimal RGB, and each animation mode supports different number of colors.  The animation speed can be customized with the `--speed <value>`, and five relative values are accepted by the device: `slowest`, `slower`, `normal`, `faster` and `fastest`.
+Colors can be specified in RGB, HSV or HSL (see [Supported color specification formats](../README.md#supported-color-specification-formats)), and each animation mode supports different number of colors.  The animation speed can be customized with the `--speed <value>`, and five relative values are accepted by the device: `slowest`, `slower`, `normal`, `faster` and `fastest`.
 
 | Mode | Colors | Notes |
 | --- | --- | --- |
diff -Naur a/docs/seasonic-e-series.md b/docs/seasonic-e-series.md
--- a/docs/seasonic-e-series.md	2020-05-10 20:38:15.786948208 +0200
+++ b/docs/seasonic-e-series.md	2020-05-10 18:05:13.885080747 +0200
@@ -21,22 +21,22 @@
 ```
 # liquidctl status
 Device 0, NZXT E500 (experimental)
-Temperature                     45.0  °C
-Fan speed                        505  rpm
-Firmware version          A017/40983
-+12V #1 output voltage         11.89  V
-+12V #1 output current          7.75  A
-+12V #1 output power           14.48  W
-+12V #2 output voltage         11.95  V
-+12V #2 output current          0.00  A
-+12V #2 output power            0.00  W
-+12V #3 output voltage         11.96  V
-+12V #3 output current          1.00  A
-+12V #3 output power           11.95  W
-+5V output voltage              4.90  V
-+5V output current              0.02  A
-+5V output power                0.11  W
-+3.3V output voltage            3.23  V
-+3.3V output current            0.01  A
-+3.3V output power              0.02  W
+Temperature                                    45.0  °C
+Fan speed                                       505  rpm
+Firmware version                         A017/40983
++12V peripherals output voltage               11.89  V
++12V peripherals output current                7.75  A
++12V peripherals output power                 14.48  W
++12V EPS/ATX12V output voltage                11.95  V
++12V EPS/ATX12V output current                 0.00  A
++12V EPS/ATX12V output power                   0.00  W
++12V motherboard/PCI-e output voltage         11.96  V
++12V motherboard/PCI-e output current          1.00  A
++12V motherboard/PCI-e output power           11.95  W
++5V combined output voltage                    4.90  V
++5V combined output current                    0.02  A
++5V combined output power                      0.11  W
++3.3V combined output voltage                  3.23  V
++3.3V combined output current                  0.01  A
++3.3V combined output power                    0.02  W
 ```
diff -Naur a/extra/krakencurve-poc b/extra/krakencurve-poc
--- a/extra/krakencurve-poc	2020-05-10 20:38:15.786948208 +0200
+++ b/extra/krakencurve-poc	2020-05-10 18:05:13.885080747 +0200
@@ -1,19 +1,25 @@
 #!/usr/bin/env python3
 
-"""Adjust Kraken speeds dynamically, with software.
+"""Adjust Kraken X42/X52/X62/X72 speeds dynamically, with software.
 
-This is just a proof of concept.
+Periodicatly adjusts the pump and fan speeds according to user-specified
+profiles.
+
+Different sensors can be used for the pump and fans; when no sensor
+is specified, the coolant temperatue is used.  Use show-sensors to view the
+available sensors.
 
 Usage:
   krakencurve-poc [options] show-sensors
-  krakencurve-poc [options] control <pump-profile> <fan-profile>
+  krakencurve-poc [options] control --pump <profile> --fan <profile>
   krakencurve-poc --help
   krakencurve-poc --version
 
 Options:
-  --use-psutil            Enable extra sensors from psutil (requires psutil)
-  --pump-sensor <sensor>  Select custom sensor for pump speed
-  --fan-sensor <sensor>   Select custom sensor for fan speed
+  --pump <profile>        Profile to use for the pump
+  --fan <profile>         Profile to use for the fan
+  --pump-sensor <sensor>  Select alternate sensor for pump speed
+  --fan-sensor <sensor>   Select alternate sensor for fan speed
   --interval <seconds>    Update interval in seconds [default: 2]
   -v, --verbose           Output additional information
   -g, --debug             Show debug information on stderr
@@ -21,8 +27,19 @@
   --help                  Show this message
 
 Examples:
-  krakencurve-poc control '(30,50),(40,100)' '(30,60),(45,100)'
-  krakencurve-poc control '(30,50),(40,100)' '(20,25),(60,100)' --use-psutil --fan-sensor 'coretemp:Package id 0'
+  krakencurve-poc show-sensors
+  krakencurve-poc control --pump '(25,50),(35,100)' --fan '(25,40),(45,100)'
+  krakencurve-poc control --pump '(25,50),(35,100)' --fan '(20,25),(60,100)' --fan-sensor 'istats.cpu'
+
+Requirements:
+  all platforms  liquidctl, including the Python APIs (pip install liquidctl)
+  Linux/FreeBSD  psutil (pip install psutil)
+  macOS          iStats (gem install iStats)
+  Windows        none, system sensors not yet supported
+
+Changelog:
+  0.0.2  MacOS support for iStats; breaking refresh of the CLI and sensor names
+  0.0.1  Initial proof-of-concept; system sensors only supported on Linux
 """
 
 import ast
@@ -34,26 +51,44 @@
 from liquidctl.driver.kraken_two import KrakenTwoDriver
 from liquidctl.util import normalize_profile, interpolate_profile
 
+if sys.platform == 'darwin':
+    import re
+    import subprocess
+elif sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
+    import psutil
+
+VERSION = '0.0.2'
 LOGGER = logging.getLogger(__name__)
 
-LIQUID_SENSOR = 'kraken:Liquid temperature'
+LIQUID_SENSOR = 'kraken.coolant'
 
 
-def read_sensors(cooler, psutil=None):
+def read_sensors(cooler):
     sensors = {}
     if cooler:
         data = {k: v for k, v, u in cooler.get_status()}
         sensors[LIQUID_SENSOR] = data['Liquid temperature']
-    if psutil:
+    if sys.platform == 'darwin':
+        istats_stdout = subprocess.check_output(['istats']).decode('utf-8')
+        for line in istats_stdout.split('\n'):
+            if line.startswith('CPU'):
+                cpu_temp = float(re.search(r'\d+\.\d+', line).group(0))
+                sensors['istats.cpu'] = cpu_temp
+                break
+    elif sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
         for m, li in psutil.sensors_temperatures().items():
             for label, current, _, _ in li:
-                sensors['{}:{}'.format(m, label)] = current
+                sensors['{}.{}'.format(m, label.lower().replace(' ', '_'))] = current
     return sensors
 
 
-def show_sensors(cooler, psutil=None):
-    sensors = read_sensors(cooler, psutil)
+def show_sensors(cooler):
+    print('{:<60}  {:>18}'.format('Sensor identifier', 'Temperature'))
+    print('-' * 80)
+    sensors = read_sensors(cooler)
     for k, v in sensors.items():
+        if k == LIQUID_SENSOR:
+            k = k + '  [default]'
         print('{:<70}  {:>6}{}'.format(k, v, '°C'))
 
 
@@ -110,13 +145,13 @@
 
 
 def control(cooler, pump_profile, fan_profile, update_interval,
-            pump_sensor, fan_sensor, psutil=None):
-    LOGGER.info('pump: following %s, profile %s', pump_sensor, str(pump_profile))
-    LOGGER.info('fan: following %s, profile %s', fan_sensor, str(fan_profile))
+            pump_sensor, fan_sensor):
+    LOGGER.info('pump following sensor %s and profile %s', pump_sensor, str(pump_profile))
+    LOGGER.info('fan following sensor %s and profile %s', fan_sensor, str(fan_profile))
     while True:
-        sensors = read_sensors(cooler, psutil)
-        LOGGER.info('pump control sensor: %.1f°C; fan control sensor: %.1f°C',
-                    sensors[pump_sensor], sensors[fan_sensor])
+        sensors = read_sensors(cooler)
+        LOGGER.info('pump control (%s): %.1f°C, fan control (%s): %.1f°C',
+                    pump_sensor, sensors[pump_sensor], fan_sensor, sensors[fan_sensor])
         pump_duty = interpolate_profile(pump_profile, sensors[pump_sensor])
         fan_duty = interpolate_profile(fan_profile, sensors[fan_sensor])
         cooler.set_instantaneous_speed('pump', pump_duty)
@@ -130,49 +165,42 @@
         doctest.testmod(verbose=True)
         sys.exit(0)
 
-    args = docopt(__doc__, version='0.0.1')
+    args = docopt(__doc__, version='krakencurve-poc v{}'.format(VERSION))
 
     if args['--debug']:
-        logging.basicConfig(level=logging.DEBUG, format='[%(levelname)s] %(name)s: %(message)s')
-        logging.getLogger('usb').setLevel(logging.DEBUG)
-        import usb._debug
-        usb._debug.enable_tracing(True)
         args['--verbose'] = True
+        logging.basicConfig(level=logging.DEBUG, format='[%(levelname)s] %(name)s: %(message)s')
+        LOGGER.debug('krakencurve-poc v%s', VERSION)
+        import liquidctl.version
+        LOGGER.debug('liquidctl v%s', liquidctl.version.__version__)
     elif args['--verbose']:
         logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
     else:
-        logging.basicConfig(level=logging.WARNING, format='%(message)s')
+        logging.basicConfig(level=logging.WARNING, format='%(levelname)s: %(message)s')
         sys.tracebacklimit = 0
 
-    if args['--use-psutil']:
-        import psutil
-    else:
-        psutil = None
-
     device = KrakenTwoDriver.find_supported_devices()[0]
     device.connect()
 
     try:
         if args['show-sensors']:
-            show_sensors(device, psutil)
+            show_sensors(device)
         elif args['control']:
             pump_sensor = args['--pump-sensor'] or LIQUID_SENSOR
             pump_max_temp = 100 if pump_sensor != LIQUID_SENSOR else 60
             fan_sensor = args['--fan-sensor'] or LIQUID_SENSOR
             fan_max_temp = 100 if fan_sensor != LIQUID_SENSOR else 60
 
-            pump_profile = parse_profile(args['<pump-profile>'], 0, pump_max_temp, minduty=50)
-            fan_profile = parse_profile(args['<fan-profile>'], 0, fan_max_temp, minduty=25)
+            pump_profile = parse_profile(args['--pump'], 0, pump_max_temp, minduty=50)
+            fan_profile = parse_profile(args['--fan'], 0, fan_max_temp, minduty=25)
 
             control(device, pump_profile, fan_profile,
                     update_interval=int(args['--interval']),
                     pump_sensor=pump_sensor,
-                    fan_sensor=fan_sensor,
-                    psutil=psutil)
+                    fan_sensor=fan_sensor)
         else:
             raise Exception('Nothing to do')
     except KeyboardInterrupt:
         LOGGER.info('Stopped by user')
     finally:
         device.disconnect()
-
diff -Naur a/extra/release-checklist.md b/extra/release-checklist.md
--- a/extra/release-checklist.md	2020-05-10 20:38:15.786948208 +0200
+++ b/extra/release-checklist.md	2020-05-10 18:05:13.885080747 +0200
@@ -9,6 +9,7 @@
  - [ ] Update liquidctl/version.py
  - [ ] Update the man page last update date
  - [ ] Make sure the CHANGELOG is up to date
+ - [ ] Update the link in the README to the stable executable for Windows
  - [ ] Commit "Prepare for release v<version>"
 
 ## Test
diff -Naur a/extra/yoda b/extra/yoda
--- a/extra/yoda	1970-01-01 01:00:00.000000000 +0100
+++ b/extra/yoda	2020-05-10 18:05:13.885080747 +0200
@@ -0,0 +1,269 @@
+#!/usr/bin/env python3
+
+"""yoda – dynamically adjust liquidctl device pump and fan speeds.
+
+Periodically adjusts pump and fan speeds according to user-specified profiles.
+
+Different sensors can be used for each channel.  Use show-sensors to view the
+sensors available for use with a particular device.
+
+To avoid jerks in pump or fan speeds, an exponential moving average is used as
+low-pass filter on sensor data.
+
+Usage:
+  yoda [options] show-sensors
+  yoda [options] control (<channel> with <profile> on <sensor> [and])...
+  yoda --help
+  yoda --version
+
+Options:
+  --interval <seconds>     Update interval in seconds [default: 2]
+  -m, --match <substring>  Filter devices by description substring
+  -n, --pick <number>      Pick among many results for a given filter
+  --vendor <id>            Filter devices by vendor id
+  --product <id>           Filter devices by product id
+  --release <number>       Filter devices by release number
+  --serial <number>        Filter devices by serial number
+  --bus <bus>              Filter devices by bus
+  --address <address>      Filter devices by address in bus
+  --usb-port <port>        Filter devices by USB port in bus
+  -v, --verbose            Output additional information
+  -g, --debug              Show debug information on stderr
+  --hid <module>           Override API for USB HIDs: usb, hid or hidraw
+  --legacy-690lc           Use Asetek 690LC in legacy mode (old Krakens)
+  --version                Display the version number
+  --help                   Show this message
+
+Examples:
+  yoda --match grid show-sensors
+  yoda --match grid control fan1 with '(20,20),(35,100)' on nct6793.systin
+  yoda --match kraken show-sensors
+  yoda --match kraken control pump with '(20,50),(50,100)' on istats.cpu and fan with '(20,25),(34,100)' on _internal.liquid
+
+Requirements:
+  all platforms  liquidctl, including the Python APIs (pip install liquidctl)
+  Linux/FreeBSD  psutil (pip install psutil)
+  macOS          iStats (gem install iStats)
+  Windows        none, system sensors not yet supported
+
+Changelog:
+  0.0.3  Remove duplicate option definition
+  0.0.2  Add low-pass filter and basic error handling.
+  0.0.1  Generalization of krakencurve-poc 0.0.2 to multiple devices.
+
+---
+
+yoda – dynamically adjust liquidctl device pump and fan speeds.
+Copyright (C) 2020  Jonas Malaco
+
+yoda is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+yoda is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <https://www.gnu.org/licenses/>.
+"""
+
+import ast
+import logging
+import math
+import sys
+import time
+
+from docopt import docopt
+
+import liquidctl.cli as _borrow
+from liquidctl.util import normalize_profile, interpolate_profile
+from liquidctl.driver import *
+
+if sys.platform == 'darwin':
+    import re
+    import subprocess
+elif sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
+    import psutil
+
+VERSION = '0.0.3'
+
+LOGGER = logging.getLogger(__name__)
+
+INTERNAL_CHIP_NAME = '_internal'
+
+MAX_FAILURES = 3
+
+
+def read_sensors(device):
+    sensors = {}
+    for k, v, u in device.get_status():
+        if u == '°C':
+            sensor_name = k.lower().replace(' ', '_').replace('_temperature', '')
+            sensors[f'{INTERNAL_CHIP_NAME}.{sensor_name}'] = v
+    if sys.platform == 'darwin':
+        istats_stdout = subprocess.check_output(['istats']).decode('utf-8')
+        for line in istats_stdout.split('\n'):
+            if line.startswith('CPU'):
+                cpu_temp = float(re.search(r'\d+\.\d+', line).group(0))
+                sensors['istats.cpu'] = cpu_temp
+                break
+    elif sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
+        for m, li in psutil.sensors_temperatures().items():
+            for label, current, _, _ in li:
+                sensor_name = label.lower().replace(' ', '_')
+                sensors[f'{m}.{sensor_name}'] = current
+    return sensors
+
+
+def show_sensors(device):
+    print('{:<60}  {:>18}'.format('Sensor identifier', 'Temperature'))
+    print('-' * 80)
+    sensors = read_sensors(device)
+    for k, v in sensors.items():
+        print('{:<70}  {:>6}{}'.format(k, v, '°C'))
+
+
+def parse_profile(arg, mintemp=0, maxtemp=100, minduty=0, maxduty=100):
+    """Parse, validate and normalize a temperature–duty profile.
+
+    >>> parse_profile('(20,30),(30,50),(34,80),(40,90)', 0, 60, 25, 100)
+    [(20, 30), (30, 50), (34, 80), (40, 90), (60, 100)]
+    >>> parse_profile('35', 0, 60, 25, 100)
+    [(0, 35), (59, 35), (60, 100)]
+
+    The profile is validated in structure and acceptable ranges.  Duty is
+    checked against `minduty` and `maxduty`.  Temperature must be between
+    `mintemp` and `maxtemp`.
+
+    >>> parse_profile('(20,30),(50,100', 0, 60, 25, 100)
+    Traceback (most recent call last):
+        ...
+    ValueError: Profile must be comma-separated (temperature, duty) tuples
+    >>> parse_profile('(20,30),(50,100,2)', 0, 60, 25, 100)
+    Traceback (most recent call last):
+        ...
+    ValueError: Profile must be comma-separated (temperature, duty) tuples
+    >>> parse_profile('(20,30),(50,97.6)', 0, 60, 25, 100)
+    Traceback (most recent call last):
+        ...
+    ValueError: Duty must be integer number between 25 and 100
+    >>> parse_profile('(20,15),(50,100)', 0, 60, 25, 100)
+    Traceback (most recent call last):
+        ...
+    ValueError: Duty must be integer number between 25 and 100
+    >>> parse_profile('(20,30),(70,100)', 0, 60, 25, 100)
+    Traceback (most recent call last):
+        ...
+    ValueError: Temperature must be integer number between 0 and 60
+
+    """
+    try:
+        val = ast.literal_eval('[' + arg + ']')
+        if len(val) == 1 and isinstance(val[0], int):
+            # for arg == '<number>' set fixed duty between mintemp and maxtemp - 1
+            val = [(mintemp, val[0]), (maxtemp - 1, val[0])]
+    except:
+        raise ValueError("Profile must be comma-separated (temperature, duty) tuples")
+    for step in val:
+        if not isinstance(step, tuple) or len(step) != 2:
+            raise ValueError("Profile must be comma-separated (temperature, duty) tuples")
+        temp, duty = step
+        if not isinstance(temp, int) or temp < mintemp or temp > maxtemp:
+            raise ValueError("Temperature must be integer between {} and {}".format(mintemp, maxtemp))
+        if not isinstance(duty, int) or duty < minduty or duty > maxduty:
+            raise ValueError('Duty must be integer between {} and {}'.format(minduty, maxduty))
+    return normalize_profile(val, critx=maxtemp)
+
+
+def control(device, channels, profiles, sensors, update_interval):
+    LOGGER.info('device: %s on bus %s and address %s', device.description, device.bus, device.address)
+    for channel, profile, sensor in zip(channels, profiles, sensors):
+        LOGGER.info('channel: %s following profile %s on %s', channel, str(profile), sensor)
+
+    averages = [None] * len(channels)
+    cutoff_freq = 1 / update_interval / 10
+    alpha = 1 - math.exp(-2 * math.pi * cutoff_freq)
+    LOGGER.info('update interval: %d s; cutoff frequency (low-pass): %.2f Hz; ema alpha: %.2f',
+                update_interval, cutoff_freq, alpha)
+
+    try:
+        # more efficient and safer API, but only supported by very few devices
+        apply_duty = device.set_instantaneous_speed
+    except AttributeError:
+        apply_duty = device.set_fixed_speed
+
+    LOGGER.info('starting...')
+    failures = 0
+    while True:
+        try:
+            sensor_data = read_sensors(device)
+            for i, (channel, profile, sensor) in enumerate(zip(channels, profiles, sensors)):
+                # compute the exponential moving average (ema), used as a low-pass filter (lpf)
+                ema = averages[i]
+                sample = sensor_data[sensor]
+                if ema is None:
+                    ema = sample
+                else:
+                    ema = alpha * sample + (1 - alpha) * ema
+                averages[i] = ema
+
+                # interpolate on sensor ema and apply corresponding duty
+                duty = interpolate_profile(profile, ema)
+                LOGGER.info('%s control: lpf(%s) = lpf(%.1f°C) = %.1f°C => duty := %d%%',
+                            channel, sensor, sample, ema, duty)
+                apply_duty(channel, duty)
+            failures = 0
+        except Exception as err:
+            failures += 1
+            LOGGER.error(err)
+            if failures >= MAX_FAILURES:
+                LOGGER.critical('Too many failures in a row: %d', failures)
+                raise
+        time.sleep(update_interval)
+
+
+if __name__ == '__main__':
+    if len(sys.argv) == 2 and sys.argv[1] == 'doctest':
+        import doctest
+        doctest.testmod(verbose=True)
+        sys.exit(0)
+
+    args = docopt(__doc__, version='yoda v{}'.format(VERSION))
+
+    if args['--debug']:
+        args['--verbose'] = True
+        logging.basicConfig(level=logging.DEBUG, format='[%(levelname)s] %(name)s: %(message)s')
+        import liquidctl.version
+        LOGGER.debug('yoda v%s', VERSION)
+        LOGGER.debug('liquidctl v%s', liquidctl.version.__version__)
+    elif args['--verbose']:
+        logging.basicConfig(level=logging.WARNING, format='%(levelname)s: %(message)s')
+        LOGGER.setLevel(logging.INFO)
+    else:
+        logging.basicConfig(level=logging.WARNING, format='%(levelname)s: %(message)s')
+        sys.tracebacklimit = 0
+
+    frwd = _borrow._make_opts(args)
+    selected = list(find_liquidctl_devices(**frwd))
+    if len(selected) > 1:
+        raise SystemExit('Too many devices, filter or select one.  See liquidctl --help and yoda --help.')
+    elif len(selected) == 0:
+        raise SystemExit('No devices matches available drivers and selection criteria')
+
+    device = selected[0]
+    device.connect()
+    try:
+        if args['show-sensors']:
+            show_sensors(device)
+        elif args['control']:
+            control(device, args['<channel>'], list(map(parse_profile, args['<profile>'])),
+                    args['<sensor>'], update_interval=int(args['--interval']))
+        else:
+            raise Exception('Nothing to do')
+    except KeyboardInterrupt:
+        LOGGER.info('stopped by user.')
+    finally:
+        device.disconnect()
diff -Naur a/liquidctl/driver/__init__.py b/liquidctl/driver/__init__.py
--- a/liquidctl/driver/__init__.py	2020-05-10 17:51:13.565727345 +0200
+++ b/liquidctl/driver/__init__.py	2020-05-10 18:07:16.326085532 +0200
@@ -39,6 +39,7 @@
 import liquidctl.driver.asetek
 import liquidctl.driver.corsair_hid_psu
 import liquidctl.driver.kraken_two
+import liquidctl.driver.kraken_three_x
 import liquidctl.driver.nzxt_smart_device
 import liquidctl.driver.seasonic
 
diff -Naur a/liquidctl/driver/kraken_three_x.py b/liquidctl/driver/kraken_three_x.py
--- a/liquidctl/driver/kraken_three_x.py	1970-01-01 01:00:00.000000000 +0100
+++ b/liquidctl/driver/kraken_three_x.py	2020-05-10 18:07:16.326085532 +0200
@@ -0,0 +1,316 @@
+"""liquidctl driver for Kraken X3 devices from NZXT.
+
+ Supported devices
+ -----------------
+
+  - [ ] NZXT Kraken X53
+  - [ ] NZXT Kraken X63
+  - [✓] NZXT Kraken X73
+
+ Supported features
+ ------------------
+
+  - [✓] general monitoring
+  - [✓] pump speed control
+  - [✓] lighting control
+  - [✓] lighting control advanced - super-breathing, super-fixed, wings, water-cooler
+  - [✓] pump speed curve
+
+ ---
+
+ liquidctl driver for Kraken X3 devices from NZXT.
+ Copyright (C) 2020–2020  Jonas Malaco
+ Copyright (C) 2020–2020  Tom Frey
+ Copyright (C) 2020–2020  each contribution's author
+
+ This file is part of liquidctl.
+
+ liquidctl is free software: you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation, either version 3 of the License, or
+ (at your option) any later version.
+
+ liquidctl is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ """
+
+import logging
+import itertools
+
+from liquidctl.driver.usb import UsbHidDriver
+from liquidctl.util import normalize_profile, interpolate_profile, clamp
+
+LOGGER = logging.getLogger(__name__)
+
+_READ_LENGTH = 64
+_WRITE_LENGTH = 64
+_MAX_READ_ATTEMPTS = 12
+_CRITICAL_TEMPERATURE = 59
+
+_COLOR_CHANNELS = {
+    'ring': 0x02,
+    'logo': 0x04,
+}
+_COLOR_MODES = {
+    # (mode, size/variant, speed scale, min colors, max colors)
+    'off':                                  (0x00, 0x00, 0, 0, 0),
+    'fixed':                                (0x00, 0x00, 0, 1, 1),
+    'fading':                               (0x01, 0x00, 1, 1, 8),
+    'super-fixed':                          (0x01, 0x01, 9, 1, 8),
+    'spectrum-wave':                        (0x02, 0x00, 2, 0, 0),
+    'backwards-spectrum-wave':              (0x02, 0x00, 2, 0, 0),
+    'marquee-3':                            (0x03, 0x03, 2, 1, 1),
+    'marquee-4':                            (0x03, 0x04, 2, 1, 1),
+    'marquee-5':                            (0x03, 0x05, 2, 1, 1),
+    'marquee-6':                            (0x03, 0x06, 2, 1, 1),
+    'backwards-marquee-3':                  (0x03, 0x03, 2, 1, 1),
+    'backwards-marquee-4':                  (0x03, 0x04, 2, 1, 1),
+    'backwards-marquee-5':                  (0x03, 0x05, 2, 1, 1),
+    'backwards-marquee-6':                  (0x03, 0x06, 2, 1, 1),
+    'covering-marquee':                     (0x04, 0x00, 2, 1, 8),
+    'covering-backwards-marquee':           (0x04, 0x00, 2, 1, 8),
+    'alternating-3':                        (0x05, 0x03, 3, 1, 2),
+    'alternating-4':                        (0x05, 0x04, 3, 1, 2),
+    'alternating-5':                        (0x05, 0x05, 3, 1, 2),
+    'alternating-6':                        (0x05, 0x06, 3, 1, 2),
+    'moving-alternating-3':                 (0x05, 0x03, 4, 1, 2),
+    'moving-alternating-4':                 (0x05, 0x04, 4, 1, 2),
+    'moving-alternating-5':                 (0x05, 0x05, 4, 1, 2),
+    'moving-alternating-6':                 (0x05, 0x06, 4, 1, 2),
+    'backwards-moving-alternating-3':       (0x05, 0x03, 4, 1, 2),
+    'backwards-moving-alternating-4':       (0x05, 0x04, 4, 1, 2),
+    'backwards-moving-alternating-5':       (0x05, 0x05, 4, 1, 2),
+    'backwards-moving-alternating-6':       (0x05, 0x06, 4, 1, 2),
+    'pulse':                                (0x06, 0x00, 5, 1, 8),
+    'breathing':                            (0x07, 0x00, 6, 1, 8),
+    'super-breathing':                      (0x03, 0x00,10, 1, 8),
+    'candle':                               (0x08, 0x00, 0, 1, 1),
+    'starry-night':                         (0x09, 0x00, 5, 1, 1),
+    'rainbow-flow':                         (0x0b, 0x00, 2, 0, 0),
+    'super-rainbow':                        (0x0c, 0x00, 2, 0, 0),
+    'rainbow-pulse':                        (0x0d, 0x00, 2, 0, 0),
+    'backwards-rainbow-flow':               (0x0b, 0x00, 2, 0, 0),
+    'backwards-super-rainbow':              (0x0c, 0x00, 2, 0, 0),
+    'backwards-rainbow-pulse':              (0x0b, 0x00, 2, 0, 0),
+    'loading':                              (0x10, 0x00, 8, 1, 1),
+    'tai-chi':                              (0x0e, 0x00, 7, 1, 2),
+    'water-cooler':                         (0x0f, 0x00, 6, 2, 2),
+    'wings':                                (None, 0x00,11, 1, 1),
+}
+_STATIC_VALUE = {
+    0x02: 0x08,
+    0x04: 0x01
+}
+_SPEED_VALUE = {
+    # (slowest, slow, normal, fast, fastest)
+    0: ([0x32, 0x00], [0x32, 0x00], [0x32, 0x00], [0x32, 0x00], [0x32, 0x00]),
+    1: ([0x50, 0x00], [0x3c, 0x00], [0x28, 0x00], [0x14, 0x00], [0x0a, 0x00]),
+    2: ([0x5e, 0x01], [0x2c, 0x01], [0xfa, 0x00], [0x96, 0x00], [0x50, 0x00]),
+    3: ([0x40, 0x06], [0x14, 0x05], [0xe8, 0x03], [0x20, 0x03], [0x58, 0x02]),
+    4: ([0x20, 0x03], [0xbc, 0x02], [0xf4, 0x01], [0x90, 0x01], [0x2c, 0x01]),
+    5: ([0x19, 0x00], [0x14, 0x00], [0x0f, 0x00], [0x07, 0x00], [0x04, 0x00]),
+    6: ([0x28, 0x00], [0x1e, 0x00], [0x14, 0x00], [0x0a, 0x00], [0x04, 0x00]),
+    7: ([0x32, 0x00], [0x28, 0x00], [0x1e, 0x00], [0x14, 0x00], [0x0a, 0x00]),
+    8: ([0x14, 0x00], [0x14, 0x00], [0x14, 0x00], [0x14, 0x00], [0x14, 0x00]),
+    9: ([0x00, 0x00], [0x00, 0x00], [0x00, 0x00], [0x00, 0x00], [0x00, 0x00]),
+    10:([0x37, 0x00], [0x28, 0x00], [0x19, 0x00], [0x0a, 0x00], [0x00, 0x00]),
+    11:([0x6e, 0x00], [0x53, 0x00], [0x39, 0x00], [0x2e, 0x00], [0x20, 0x00]),
+}
+_ANIMATION_SPEEDS = {
+    'slowest': 0x0,
+    'slower': 0x1,
+    'normal': 0x2,
+    'faster': 0x3,
+    'fastest': 0x4,
+}
+_ACCESSORY_NAMES = {
+    0x01: "HUE+ LED Strip",
+    0x02: "AER RGB 1",
+    0x04: "HUE 2 LED Strip 300 mm",
+    0x05: "HUE 2 LED Strip 250 mm",
+    0x06: "HUE 2 LED Strip 200 mm",
+    0x08: "HUE 2 Cable Comb",
+    0x09: "HUE 2 Underglow 300 mm",
+    0x0a: "HUE 2 Underglow 200 mm",
+    0x0b: "AER RGB 2 120 mm",
+    0x0c: "AER RGB 2 140 mm",
+    0x10: "Kraken X3 Pump Ring",
+    0x11: "Kraken X3 Pump Logo",
+}
+
+
+class KrakenThreeXDriver(UsbHidDriver):
+    """liquidctl driver for Kraken X3 devices from NZXT."""
+
+    SUPPORTED_DEVICES = [
+        (0x1e71, 0x2007, None, 'NZXT Kraken X (X53, X63 or X73) (experimental)', {})
+    ]
+
+    def initialize(self, **kwargs):
+        """Initialize the device.
+
+        Reports the current firmware of the device.
+
+        Returns a list of (key, value, unit) tuples.
+        """
+        self.device.clear_enqueued_reports()
+        # request static infos
+        self._write([0x10, 0x01])  # firmware info
+        self._write([0x20, 0x03])  # lighting info
+        # initialize
+        self._write([0x70, 0x02, 0x01, 0xb8, 0x0b])
+        self._write([0x70, 0x01])
+        status = []
+
+        def parse_firm_info(msg):
+            fw = '{}.{}.{}'.format(msg[0x11], msg[0x12], msg[0x13])
+            status.append(('Firmware version', fw, ''))
+
+        def parse_led_info(msg):
+            """
+            FIXME: is is possible to attach other accessories to the pump?
+            currently not possible to address devices via led id e.g. "led1"
+            accessory_id: ? (LED 1 - ?) & 0x10 (LED 2 - ring) & 0x11 (LED 3 - logo)
+            """
+            num_light_channels = msg[14]  # the 15th byte (index 14) is # of light channels
+            accessories_per_channel = 6  # each lighting channel supports up to 6 accessories
+            light_accessory_index = 15  # offset in msg of info about first light accessory
+            for light_channel in range(num_light_channels):
+                for accessory_num in range(accessories_per_channel):
+                    accessory_id = msg[light_accessory_index]
+                    light_accessory_index += 1
+                    if accessory_id != 0:
+                        status.append(('LED {} accessory {}'.format(light_channel + 1, accessory_num + 1),
+                                       _ACCESSORY_NAMES.get(accessory_id, 'Unknown'), ''))
+
+        self._read_until({b'\x11\x01': parse_firm_info, b'\x21\x03': parse_led_info})
+        self.device.release()
+        return sorted(status)
+
+    def get_status(self, **kwargs):
+        """Get a status report.
+
+        Returns a list of `(property, value, unit)` tuples.
+        """
+        msg = self._read()
+        return [
+            ('Liquid temperature', msg[15] + msg[14] / 10, '°C'),
+            ('Pump speed', msg[18] << 8 | msg[17], 'rpm'),
+            ('Pump duty', msg[19], '%'),
+        ]
+
+    def set_color(self, channel, mode, colors, speed='normal', **kwargs):
+        """Set the color mode for a specific channel."""
+        cid = _COLOR_CHANNELS[channel]
+        _, _, _, mincolors, maxcolors = _COLOR_MODES[mode]
+        colors = [[g, r, b] for [r, g, b] in colors]
+        if len(colors) < mincolors:
+            raise ValueError('Not enough colors for mode={}, at least {} required'.format(mode, mincolors))
+        elif maxcolors == 0:
+            if colors:
+                LOGGER.warning('too many colors for mode=%s, none needed', mode)
+            colors = [[0, 0, 0]]  # discard the input but ensure at least one step
+        elif len(colors) > maxcolors:
+            LOGGER.warning('too many colors for mode=%s, dropping to %i', mode, maxcolors)
+            colors = colors[:maxcolors]
+        sval = _ANIMATION_SPEEDS[speed]
+        self._write_colors(cid, mode, colors, sval)
+        self.device.release()
+
+    def set_speed_profile(self, channel, profile, **kwargs):
+        """Set channel to use a speed profile."""
+        if channel != 'pump':
+            assert False, 'kraken X3 devices only support changing pump speeds'
+        header = [0x72, 0x01, 0x00, 0x00]
+        norm = normalize_profile(profile, _CRITICAL_TEMPERATURE)
+        interp = [(interpolate_profile(norm, t)) for t in range(20, 60)]
+        LOGGER.debug('setting pump curve: %s', [(num + 20, duty) for (num, duty) in enumerate(interp)])
+        self._write(header + interp)
+
+    def set_fixed_speed(self, channel, duty, **kwargs):
+        """Set channel to a fixed speed duty."""
+        duty = clamp(duty, 20, 100)
+        self.set_speed_profile(channel, [(i, duty) for i in range(20, 60)])
+        self.device.release()
+
+    def _read(self):
+        data = self.device.read(_READ_LENGTH)
+        self.device.release()
+        LOGGER.debug('received %s', ' '.join(format(i, '02x') for i in data))
+        return data
+
+    def _read_until(self, parsers):
+        for _ in range(_MAX_READ_ATTEMPTS):
+            msg = self.device.read(_READ_LENGTH)
+            LOGGER.debug('received %s', ' '.join(format(i, '02x') for i in msg))
+            prefix = bytes(msg[0:2])
+            func = parsers.pop(prefix, None)
+            if func:
+                func(msg)
+            if not parsers:
+                return
+        assert False, f'missing messages (attempts={_MAX_READ_ATTEMPTS}, missing={len(parsers)})'
+
+    def _write(self, data):
+        padding = [0x0] * (_WRITE_LENGTH - len(data))
+        LOGGER.debug('write %s (and %i padding bytes)', ' '.join(format(i, '02x') for i in data), len(padding))
+        self.device.write(data + padding)
+
+    def _write_colors(self, cid, mode, colors, sval):
+        mval, size_variant, speed_scale, mincolors, maxcolors = _COLOR_MODES[mode]
+        color_count = len(colors)
+        if 'super-fixed' == mode or 'super-breathing' == mode:
+            color = list(itertools.chain(*colors)) + [0x00, 0x00, 0x00] * (maxcolors - color_count)
+            speed_value = _SPEED_VALUE[speed_scale][sval]
+            self._write([0x22, 0x10, cid, 0x00] + color)
+            self._write([0x22, 0x11, cid, 0x00])
+            self._write([0x22, 0xa0, cid, 0x00, mval] + speed_value + [0x08, 0x00, 0x00, 0x80, 0x00, 0x32, 0x00, 0x00, 0x01])
+        elif mode == 'wings':  # wings requires special handling
+            self._write([0x22, 0x10, cid])  # clear out all independent LEDs
+            self._write([0x22, 0x11, cid])  # clear out all independent LEDs
+            color_lists = {}
+            color_lists[0] = colors[0] * 2
+            color_lists[1] = [int(x // 2.5) for x in color_lists[0]]
+            color_lists[2] = [int(x // 4) for x in color_lists[1]]
+            color_lists[3] = [0x00] * 8
+            for i in range(8):   #  send color scheme first, before enabling wings mode
+                mod = 0x05 if i in [3, 7] else 0x01
+                speed_value = _SPEED_VALUE[speed_scale][sval]
+                direction = [0x04, 0x84] if i // 4 == 0 else [0x84, 0x04]
+                msg = ([0x22, 0x20, cid, i, 0x04] + speed_value + [mod] + [0x00] * 7 + [0x02] + direction + [0x00] * 10)
+                self._write(msg + color_lists[i % 4])
+            self._write([0x22, 0x03, cid, 0x08])   # this actually enables wings mode
+        else:
+            opcode = [0x2a, 0x04]
+            address = [cid, cid]
+            speed_value = _SPEED_VALUE[speed_scale][sval]
+            header = opcode + address + [mval] + speed_value
+            color = list(itertools.chain(*colors)) + [0, 0, 0] * (16 - color_count)
+            if 'marquee' in mode:
+                backwards_byte = 0x04
+            elif mode == 'starry-night' or 'moving-alternating' in mode:
+                backwards_byte = 0x01
+            else:
+                backwards_byte = 0x00
+            if 'backwards' in mode:
+                backwards_byte += 0x02
+            if mode == 'fading' or mode == 'pulse' or mode == 'breathing':
+                mode_related = 0x08
+            elif mode == 'tai-chi':
+                mode_related = 0x05
+            elif mode == 'water-cooler':
+                mode_related = 0x05
+                color_count = 0x01
+            elif mode == 'loading':
+                mode_related = 0x04
+            else:
+                mode_related = 0x00
+            static_byte = _STATIC_VALUE[cid]
+            led_size = size_variant if mval == 0x03 or mval == 0x05 else 0x03
+            footer = [backwards_byte, color_count, mode_related, static_byte, led_size]
+            self._write(header + color + footer)
diff -Naur a/liquidctl/driver/kraken_two.py b/liquidctl/driver/kraken_two.py
--- a/liquidctl/driver/kraken_two.py	2020-05-10 20:38:15.786948208 +0200
+++ b/liquidctl/driver/kraken_two.py	2020-05-10 18:07:16.330085433 +0200
@@ -209,13 +209,14 @@
         """Set channel to use a speed profile."""
         if not self.supports_cooling_profiles:
             raise NotImplementedError()
+        norm = normalize_profile(profile, _CRITICAL_TEMPERATURE)
+        # due to a firmware limitation the same set of temperatures must be
+        # used on both channels; we reduce the number of writes by trimming the
+        # interval and/or resolution to the most useful range
+        stdtemps = list(range(20, 50)) + list(range(50, 60, 2)) + [60]
+        interp = [(t, interpolate_profile(norm, t)) for t in stdtemps]
         cbase, dmin, dmax = _SPEED_CHANNELS[channel]
-        # ideally we could just call normalize_profile (optionally followed by autofill_profile),
-        # but Kraken devices currently require the same set of temperatures on both channels
-        stdtemps = range(20, 62, 2)
-        tmp = normalize_profile(profile, _CRITICAL_TEMPERATURE)
-        norm = [(t, interpolate_profile(tmp, t)) for t in stdtemps]
-        for i, (temp, duty) in enumerate(norm):
+        for i, (temp, duty) in enumerate(interp):
             duty = clamp(duty, dmin, dmax)
             LOGGER.info('setting %s PWM duty to %i%% for liquid temperature >= %i°C',
                          channel, duty, temp)
diff -Naur a/liquidctl/driver/nzxt_smart_device.py b/liquidctl/driver/nzxt_smart_device.py
--- a/liquidctl/driver/nzxt_smart_device.py	2020-05-10 20:38:15.786948208 +0200
+++ b/liquidctl/driver/nzxt_smart_device.py	2020-05-10 18:07:16.330085433 +0200
@@ -55,6 +55,11 @@
 A microphone is still present onboard for noise level optimization through CAM
 and AI.
 
+RGB & Fan Controller
+--------------------
+
+The NZXT RGB & Fan Controller is a retail version of the NZXT Smart Device V2.
+
 HUE 2
 -----
 
@@ -381,6 +386,7 @@
         0x02: "AER RGB 1",
         0x04: "HUE 2 LED Strip 300 mm",
         0x05: "HUE 2 LED Strip 250 mm",
+        0x06: "HUE 2 LED Strip 200 mm",
         0x08: "HUE 2 Cable Comb",
         0x0a: "HUE 2 Underglow 200 mm",
         0x0b: "AER RGB 2 120 mm",
diff -Naur a/liquidctl/driver/seasonic.py b/liquidctl/driver/seasonic.py
--- a/liquidctl/driver/seasonic.py	2020-05-10 20:38:15.786948208 +0200
+++ b/liquidctl/driver/seasonic.py	2020-05-10 18:07:16.330085433 +0200
@@ -50,7 +50,7 @@
 _ATTEMPTS = 3
 
 _SEASONIC_READ_FIRMWARE_VERSION = CMD.MFR_SPECIFIC_FC
-_RAILS = ['+12V #1', '+12V #2', '+12V #3', '+5V', '+3.3V']
+_RAILS = ['+12V peripherals', '+12V EPS/ATX12V', '+12V motherboard/PCI-e', '+5V combined', '+3.3V combined']
 
 
 class SeasonicEDriver(UsbHidDriver):
@@ -155,5 +155,5 @@
     def _get_fw_versions(self):
         minor, major = self._exec_read(_SEASONIC_READ_FIRMWARE_VERSION, 2)
         human_ver = f'{bytes([major]).decode()}{minor:03}'
-        ascam_ver = int.from_bytes(bytes.fromhex('A017'), byteorder='big')
+        ascam_ver = int.from_bytes(bytes.fromhex(human_ver), byteorder='big')
         return (human_ver, ascam_ver)
diff -Naur a/liquidctl/driver/usb.py b/liquidctl/driver/usb.py
--- a/liquidctl/driver/usb.py	2020-05-10 20:38:15.786948208 +0200
+++ b/liquidctl/driver/usb.py	2020-05-10 18:07:16.330085433 +0200
@@ -89,8 +89,17 @@
 except:
     hidraw = hid
 
+from usb.util import ENDPOINT_IN, ENDPOINT_OUT, ENDPOINT_TYPE_INTR, CTRL_TYPE_CLASS, \
+                     CTRL_RECIPIENT_INTERFACE
+
 from liquidctl.driver.base import BaseDriver, BaseBus, find_all_subclasses
 
+_CLASS_HID = 3
+_ENDPOINT_DIR_MASK = 0x80
+_ENDPOINT_TRANSFER_TYPE_MASK = 7
+_HID_SET_REPORT = 0x09
+_HID_OUTPUT = 2
+
 LOGGER = logging.getLogger(__name__)
 
 
@@ -241,40 +250,45 @@
      - OpenUSB
     """
 
-    _DEFAULT_INTERFACE = 0  # FIXME not necessarily the desired interface
-
-    def __init__(self, usbdev):
+    def __init__(self, usbdev, bInterfaceNumber=None):
         self.api = usb
         self.usbdev = usbdev
+        self.bInterfaceNumber = bInterfaceNumber
         self._attached = False
 
-    def open(self):
+    def _select_interface(self, cfg):
+        return self.bInterfaceNumber or 0
+
+    def open(self, bInterfaceNumber=0):
         """Connect to the device.
 
-        Replace the kernel driver (Linux only) and set the device configuration
-        to the first available one, if none has been set.
+        Ensure the device is configured and replace the kernel kernel on the
+        selected interface, if necessary.
         """
-        if (sys.platform.startswith('linux') and
-                self.usbdev.is_kernel_driver_active(self._DEFAULT_INTERFACE)):
-            LOGGER.debug('replacing stock kernel driver with libusb')
-            self.usbdev.detach_kernel_driver(self._DEFAULT_INTERFACE)
-            self._attached = True
         try:
             cfg = self.usbdev.get_active_configuration()
         except usb.core.USBError:
             LOGGER.debug('setting the (first) configuration')
-            self.usbdev.set_configuration()
-            # FIXME device is not ready yet
+            self.usbdev.set_configuration()  # assume the first configuration
+            # FIXME device or handle might not be ready for use after set_configuration()
+            cfg = self.usbdev.get_active_configuration()
+        self.bInterfaceNumber = self._select_interface(cfg)
+        LOGGER.debug('selected interface: %d', self.bInterfaceNumber)
+        if (sys.platform.startswith('linux') and
+                self.usbdev.is_kernel_driver_active(self.bInterfaceNumber)):
+            LOGGER.debug('replacing stock kernel driver with libusb')
+            self.usbdev.detach_kernel_driver(self.bInterfaceNumber)
+            self._attached = True
 
     def claim(self):
         """Explicitly claim the device from other programs."""
         LOGGER.debug('explicitly claim interface')
-        usb.util.claim_interface(self.usbdev, self._DEFAULT_INTERFACE)
+        usb.util.claim_interface(self.usbdev, self.bInterfaceNumber)
 
     def release(self):
         """Release the device to other programs."""
         LOGGER.debug('ensure interface is released')
-        usb.util.release_interface(self.usbdev, self._DEFAULT_INTERFACE)
+        usb.util.release_interface(self.usbdev, self.bInterfaceNumber)
 
     def close(self):
         """Disconnect from the device.
@@ -284,7 +298,7 @@
         self.release()
         if self._attached:
             LOGGER.debug('restoring stock kernel driver')
-            self.usbdev.attach_kernel_driver(self._DEFAULT_INTERFACE)
+            self.usbdev.attach_kernel_driver(self.bInterfaceNumber)
             self._attached = False
 
     def read(self, endpoint, length, timeout=None):
@@ -358,13 +372,35 @@
     """
     def __init__(self, usbdev):
         super().__init__(usbdev)
-        self.hidin = 0x81
-        self.hidout = 0x1  # FIXME apart from NZXT HIDs, usually ctrl (0x0)
+        self.ep_in = None
+        self.ep_out = None
+
+    def _select_interface(self, cfg):
+        hid_intf = None
+        for intf in cfg:
+            if intf.bInterfaceClass != _CLASS_HID:
+                continue
+            hid_intf = intf
+            for ep in intf:
+                if (ep.bmAttributes & _ENDPOINT_TRANSFER_TYPE_MASK) != ENDPOINT_TYPE_INTR:
+                    continue
+                if not self.ep_in and (ep.bEndpointAddress & _ENDPOINT_DIR_MASK) == ENDPOINT_IN:
+                    self.ep_in = ep.bEndpointAddress
+                elif not self.ep_out:
+                    self.ep_out = ep.bEndpointAddress
+            break
+        if not hid_intf:
+            raise usb.core.USBError('Missing a HID interface')
+        if not self.ep_in:
+            raise usb.core.USBError('Missing an interrupt IN endpoint')
+        # if ep_out is not available Set_Report will be sent on CTRL OUT (0x00)
+        LOGGER.debug('hid endpoints: %#04x (IN), %#04x (OUT)', self.ep_in, self.ep_out or 0)
+        return hid_intf.bInterfaceNumber
 
     def clear_enqueued_reports(self):
         """Clear already enqueued incoming reports.
 
-        This methodis available for compatibitily with HidapiDevice, but here
+        This method is available for compatibitily with HidapiDevice, but here
         it is as a no-op since we always directly read from the device, and
         thus avoid any queuing of reports at the OS level.
         """
@@ -372,11 +408,36 @@
 
     def read(self, length):
         """Read raw report from HID."""
-        return self.usbdev.read(self.hidin, length, timeout=0)
+        return self.usbdev.read(self.ep_in, length, timeout=0)
 
     def write(self, data):
-        """Write raw report to HID."""
-        return self.usbdev.write(self.hidout, data, timeout=0)
+        """Write raw report to HID.
+
+        The first byte of the buffer passed to write() should be set to the
+        report number.  If the device does not use numbered reports, the first
+        byte should be set to 0. The report data itself should begin at the
+        second byte.
+
+        The distinction between report number and data is
+        important for compatibility with kernel APIs and HidapiDevice.
+        """
+        # report_id == 0 means it's not used, so it isn't actually sent;
+        # mimicking hidapi on libusb, this is transparently handled
+        report_id = data[0]
+        if not report_id:
+            data = data[1:]
+        if self.ep_out:
+            sent = self.usbdev.write(self.ep_out, data, timeout=0)
+        else:
+            sent = self.ctrl_transfer(
+                    bmRequestType=CTRL_TYPE_CLASS | CTRL_RECIPIENT_INTERFACE | ENDPOINT_OUT,
+                    bRequest=_HID_SET_REPORT,
+                    wValue=(_HID_OUTPUT << 8) | report_id,
+                    wIndex=self.bInterfaceNumber,
+                    data_or_wLength=data)
+        if not report_id:
+            sent += 1
+        return sent
 
 
 class HidapiDevice:
@@ -443,7 +504,13 @@
         return self.hiddev.read(length)
 
     def write(self, data):
-        """Write raw report to HID."""
+        """Write raw report to HID.
+
+        The first byte of the buffer passed to write() should be set to the
+        report number.  If the device does not use numbered reports, the first
+        byte should be set to 0. The report data itself should begin at the
+        second byte.
+        """
         return self.hiddev.write(data)
 
     @classmethod
@@ -527,8 +594,8 @@
                 continue
             if usb_port and handle.port != usb_port:
                 continue
-            LOGGER.debug('probing drivers for device %s:%s', hex(handle.vendor_id),
-                         hex(handle.product_id))
+            LOGGER.debug('probing drivers for device %04x:%04x', handle.vendor_id,
+                         handle.product_id)
             for drv in drivers:
                 yield from drv.probe(handle, vendor=vendor, product=product, **kwargs)
 
@@ -547,7 +614,7 @@
                 continue
             if usb_port and handle.port != usb_port:
                 continue
-            LOGGER.debug('probing drivers for device %s:%s', hex(handle.vendor_id),
-                         hex(handle.product_id))
+            LOGGER.debug('probing drivers for device %04x:%04x', handle.vendor_id,
+                         handle.product_id)
             for drv in drivers:
                 yield from drv.probe(handle, vendor=vendor, product=product, **kwargs)
diff -Naur a/liquidctl/util.py b/liquidctl/util.py
--- a/liquidctl/util.py	2020-05-10 20:38:15.786948208 +0200
+++ b/liquidctl/util.py	2020-05-10 18:07:16.330085433 +0200
@@ -19,8 +19,11 @@
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
 """
 
+import colorsys
 import logging
 
+from ast import literal_eval
+
 LOGGER = logging.getLogger(__name__)
 
 
@@ -91,16 +94,71 @@
 
 
 def color_from_str(x):
-    """Parse a RGB color from a hexadecimal string.
+    """Parse a color, and, if necessary, translate it into the RGB model.
+
+    The input string can be encoded in several formats:
+
+     - ffffff: hexadecimal RGB implicit tuple
+     - rgb(255, 255, 255): explicit RGB, R,G,B ∊ [0, 255]
+     - hsv(360, 100, 100): explicit HSV, H ∊ [0, 360], SV ∊ [0, 100]
+     - hsl(360, 100, 100): explicit HSL, H ∊ [0, 360], SV ∊ [0, 100]
 
     >>> color_from_str('fF7f3f')
     [255, 127, 63]
+    >>> color_from_str('Rgb(255, 127, 63)')
+    [255, 127, 63]
+    >>> color_from_str('Hsv(20, 75, 100)')
+    [255, 128, 64]
+    >>> color_from_str('Hsl(20, 100, 62)')
+    [255, 126, 61]
 
     >>> color_from_str('fF7f3f1f')
     Traceback (most recent call last):
         ...
     ValueError: Cannot parse color: fF7f3f1f
+    >>> color_from_str('rgb()')
+    Traceback (most recent call last):
+        ...
+    ValueError: Expected 3-element triple: rgb()
+    >>> color_from_str('rgb(255)')
+    Traceback (most recent call last):
+        ...
+    ValueError: Expected 3-element triple: rgb(255)
+    >>> color_from_str('rgb(300, 255, 255)')
+    Traceback (most recent call last):
+        ...
+    ValueError: Expected value in range [0, 255]: 300 in rgb(300, 255, 255)
+    >>> color_from_str('hsv(360, 150, 100)')
+    Traceback (most recent call last):
+        ...
+    ValueError: Expected value in range [0, 100]: 150 in hsv(360, 150, 100)
+    >>> color_from_str('hsl(360, 100, 150)')
+    Traceback (most recent call last):
+        ...
+    ValueError: Expected value in range [0, 100]: 150 in hsl(360, 100, 150)
     """
-    if len(x) != 6:
-        raise ValueError('Cannot parse color: {}'.format(x))
-    return list(bytes.fromhex(x))
+
+    def parse_triple(sub, maxvalues):
+        literal = literal_eval(sub)
+        if not isinstance(literal, tuple) or len(literal) != 3:
+            raise ValueError(f'Expected 3-element triple: {x}')
+        for value, maxvalue in zip(literal, maxvalues):
+            if not isinstance(value, int) and not isinstance(value, float):
+                raise ValueError(f'Expected float or int: {value} in {x}')
+            if value < 0 or value > maxvalue:
+                raise ValueError(f'Expected value in range [0, {maxvalue}]: {value} in {x}')
+        return literal
+
+    if x.lower().startswith('rgb('):
+        r, g, b = parse_triple(x[3:], (255, 255, 255))
+        return [r, g, b]
+    elif x.lower().startswith('hsv('):
+        h, s, v = parse_triple(x[3:], (360, 100, 100))
+        return list(map(lambda b: round(b*255), colorsys.hsv_to_rgb(h/360, s/100, v/100)))
+    elif x.lower().startswith('hsl('):
+        h, s, l = parse_triple(x[3:], (360, 100, 100))
+        return list(map(lambda b: round(b*255), colorsys.hls_to_rgb(h/360, l/100, s/100)))
+    elif len(x) == 6:
+        return list(bytes.fromhex(x))
+    else:
+        raise ValueError(f'Cannot parse color: {x}')
diff -Naur a/liquidctl.8 b/liquidctl.8
--- a/liquidctl.8	2020-05-10 20:38:15.786948208 +0200
+++ b/liquidctl.8	2020-05-10 18:05:13.885080747 +0200
@@ -75,9 +75,17 @@
 variable temperature\–duty curves, or both.
 .PP
 \fBliquidctl set \fIchannel\fB color\fR allows the user to configure and set
-lighting modes.  Each color is specified in hexadecimal RGB, without prefixes
-(e.g. \fIff2608\fR).  Supported modes and additional options vary by device and
-are listed in later sections of this manual.
+lighting modes.  Supported lighting modes and additional options vary by device
+and are listed in later sections of this manual.  Each color can be specified
+as:
+.IP \(bu
+hexadecimal RGB without prefix: \fIff7f3f\fR;
+.IP \(bu
+decimal RGB triple, R,G,B ∊ [0, 255]: \fIrgb(255,127,63)\fR;
+.IP \(bu
+hue\-saturation\-value HSV triple, H ∊ [0, 360], S,V ∊ [0, 100]: \fIhsv(20,75,100)\fR;
+.IP \(bu
+hue\-saturation\-lightness HSL triple, H ∊ [0, 360], S,L ∊ [0, 100]: \fIhsl(20,100,62)\fR.
 .
 .SH OPTIONS
 .
@@ -314,6 +322,7 @@
 .SS NZXT HUE 2
 .SS NZXT HUE 2 Ambient
 .SS NZXT Smart Device V2
+.SS NZXT RGB & Fan Controller
 Fan channels (only Smart Device V2): \fIfan[1\(en3]\fR.
 .PP
 Lighting channels: \fIled[1\(en2]\fR.
diff -Naur a/README.md b/README.md
--- a/README.md	2020-05-10 20:38:15.786948208 +0200
+++ b/README.md	2020-05-10 18:07:16.326085532 +0200
@@ -12,11 +12,13 @@
 Device ID 1: NZXT Kraken X (X42, X52, X62 or X72)
 
 # liquidctl initialize all
-# liquidctl --match smart set fan1 speed 50
-# liquidctl --match smart set led color fading 350017 ff2608
+
 # liquidctl --match kraken set fan speed  20 30  30 50  34 80  40 90  50 100
 # liquidctl --match kraken set sync color spectrum-wave
 
+# liquidctl --match smart set led color fading 350017 ff2608
+# liquidctl --match smart set fan1 speed 50
+
 # liquidctl status
 NZXT Smart Device (V1)
 ├── Fan 1                        PWM  
@@ -44,20 +46,19 @@
 ## Table of contents
 
 1. [Supported devices](#supported-devices)
-2. [Pre-built packages and executables](#pre-built-packages-and-executables)
-3. [Installing from sources](#installing-from-sources)
-    1. [Grabbing releases with pip](#grabbing-releases-with-pip)
-    2. [Testing and developing new features](#testing-and-developing-new-features)
-    3. [Additional requirements on Linux](#additional-requirements-on-linux)
-    4. [Additional requirements on Windows](#additional-requirements-on-windows)
-    5. [Additional requirements on Mac OS](#additional-requirements-on-mac-os)
-4. [The command-line interface](#introducing-the-command-line-interface)
-5. [Automation and running at boot](#automation-and-running-at-boot)
+2. [Installing on Linux](#installing-on-linux)
+3. [Installing on Windows](#installing-on-windows)
+4. [Installing on macOS](#installing-on-macos)
+5. [The command-line interface](#introducing-the-command-line-interface)
+    1. [Listing and selecting devices](#listing-and-selecting-devices)
+    2. [Initializing and interacting with devices](#initializing-and-interacting-with-devices)
+    3. [Supported color specification formats](#supported-color-specification-formats)
+6. [Automation and running at boot](#automation-and-running-at-boot)
     1. [Set up Linux using systemd](#set-up-linux-using-systemd)
     2. [Set up Windows using Task Scheduler](#set-up-windows-using-task-scheduler)
-    3. [Set up Mac OS using launchd](#set-up-mac-os-using-launchd)
-6. [License](#license)
-7. [Related projects](#related-projects)
+    3. [Set up macOS using launchd](#set-up-macos-using-launchd)
+7. [License](#license)
+8. [Related projects](#related-projects)
 
 
 ## Supported devices
@@ -66,13 +67,14 @@
 
 | Family | Documentation | Notes |
 | --- | --- | --- |
-| Corsair H80i GT, H100i GTX, H110i GTX | [documentation](docs/asetek-690lc.md) | <sup>_E_</sup> |
-| Corsair H80i v2, H100i v2, H115i | [documentation](docs/asetek-690lc.md) | |
-| EVGA CLC 120 (CL12), 240, 280, 360 | [documentation](docs/asetek-690lc.md) | |
+| Corsair H80i GT, H100i GTX, H110i GTX | [documentation](docs/asetek-690lc.md) | <sup>_E, Z_</sup> |
+| Corsair H80i v2, H100i v2, H115i | [documentation](docs/asetek-690lc.md) | <sup>_Z_</sup> |
+| EVGA CLC 120 (CL12), 240, 280, 360 | [documentation](docs/asetek-690lc.md) | <sup>_Z_</sup> |
 | NZXT Kraken M22 | [documentation](docs/nzxt-kraken-x-3rd-generation.md) | |
-| NZXT Kraken X40, X60 | [documentation](docs/asetek-690lc.md) | <sup>_E, L_</sup> |
-| NZXT Kraken X31, X41, X61 | [documentation](docs/asetek-690lc.md) | <sup>_E, L_</sup> |
+| NZXT Kraken X40, X60 | [documentation](docs/asetek-690lc.md) | <sup>_E, L, Z_</sup> |
+| NZXT Kraken X31, X41, X61 | [documentation](docs/asetek-690lc.md) | <sup>_E, L, Z_</sup> |
 | NZXT Kraken X42, X52, X62, X72 | [documentation](docs/nzxt-kraken-x-3rd-generation.md) | |
+| NZXT Kraken X53, X63, X73 | [documentation](docs/nzxt-kraken-x3-devices.md) | <sup>_E_</sup> |
 
 ### Other parts
 
@@ -84,115 +86,160 @@
 | NZXT Grid+ V3 | [documentation](docs/nzxt-smart-device.md) | |
 | NZXT HUE 2, HUE 2 Ambient | [documentation](docs/nzxt-smart-device-v2.md) | <sup>_E_</sup> |
 | NZXT Smart Device | [documentation](docs/nzxt-smart-device.md) | |
-| NZXT Smart Device V2 | [documentation](docs/nzxt-smart-device-v2.md) | <sup>E</sup> |
+| NZXT Smart Device V2, RGB & Fan Controller | [documentation](docs/nzxt-smart-device-v2.md) | <sup>E</sup> |
 
 <sup>_E_</sup> _Experimental._  
 <sup>_L_</sup> _Requires the `--legacy-690lc` flag._  
+<sup>_Z_</sup> _Requires replacing the device driver [on Windows](#installing-on-windows)._  
 
 
-## Pre-built packages and executables
+## Installing on Linux
 
-Packages for Linux distributions:
+Packages are available for certain Linux distributions and package managers:
 
- - ArchLinux: [python-liquidctl<sup>AUR</sup>](https://aur.archlinux.org/packages/python-liquidctl/), [python-liquidctl-git<sup>AUR</sup>](https://aur.archlinux.org/packages/python-liquidctl-git/)
- - Fedora: [liquidctl, python3-liquidctl](https://pkgs.org/download/liquidctl)
- - Linuxbrew tap: [jonasmalacofilho/homebrew-liquidctl](https://github.com/jonasmalacofilho/homebrew-liquidctl)
+ - Alpine Linux: [liquidctl](https://pkgs.alpinelinux.org/packages?name=liquidctl)
+ - ArchLinux/Manjaro: [liquidctl<sup>AUR</sup>](https://aur.archlinux.org/packages/liquidctl/), [liquidctl-git<sup>AUR</sup>](https://aur.archlinux.org/packages/liquidctl-git/)
+ - Fedora: [liquidctl](https://apps.fedoraproject.org/packages/liquidctl)
+ - Debian/Ubuntu: work in progress (issue #62), continue reading for manual installation instructions
 
-Pre-built binaries for Windows:
+Alternatively, it is possible to install liquidctl from PyPI or directly from the source code repository.  In these cases the following dependencies are necessary:
 
- - Official releases: check the assets in the [Releases](https://github.com/jonasmalacofilho/liquidctl/releases) tab
- - Development builds: select from the [last builds](https://ci.appveyor.com/project/jonasmalacofilho/liquidctl/history) on AppVeyor and check the artifacts tab
- - _Some devices may require an [additional kernel driver](#additional-requirements-on-windows)_
+| Dependency | Arch Linux | Fedora | Ubuntu |
+| --- | --- | --- | --- |
+| Python 3.6+ | python | python3 | python3 |
+| libusb-1.0 | libusb-1.0 | libusbx | libusb-1.0-0 |
+| pkg_resources | python-setuptools | python3-setuptools | python3-pkg-resources |
+| docopt | python-docopt | python3-docopt | python3-docopt |
+| PyUSB | python-pyusb | python3-pyusb | python3-usb |
+| cython-hidapi | python-hidapi | python3-hidapi | python3-hid |
 
-Homebrew formula for Mac OS:
+If cython-hidapi is to be installed from sources or directly from PyPI, then build tools and development headers for Python, libusb-1.0 and libudev are also needed.
 
- - Homebrew tap: [jonasmalacofilho/homebrew-liquidctl](https://github.com/jonasmalacofilho/homebrew-liquidctl)
+To install any release from PyPI, *pip* should be used:
 
+```
+# pip install liquidctl
+# pip install liquidctl==<version>
+```
+
+For the latest changes and to contribute back to the project, it is best to clone the source code repository and install liquidctl from your local copy:
 
-## Installing from sources
+```
+$ git clone https://github.com/jonasmalacofilho/liquidctl
+$ cd liquidctl
+# python setup.py install
+```
 
-liquidctl runs on [Python](https://www.python.org/) 3.6 or later and uses [libusb](https://github.com/libusb/libusb) and [HIDAPI](https://github.com/libusb/hidapi) to communicate with devices.
+_Note: in systems that default to Python 2, replace `pip` and `python` by `pip3` and `python3`._  
 
-The most important Python dependencies are [PyUSB](https://github.com/pyusb/pyusb) and [cython-hidapi](https://github.com/trezor/Cython-hidapI), but a few other libraries (e.g. docopt) are used as well; all of them are listed in `setup.py`.
 
-On Windows some devices might require the installation of a special kernel driver.  HIDAPI's dependencies can also vary depending on the platform.  These and other platform details and quirks are documented bellow, after common installation instructions.
+## Installing on Windows
 
-### Grabbing releases with pip
+A pre-built executable for the last stable version is available in [liquidctl-1.3.3-bin-windows-x86_64.zip](https://github.com/jonasmalacofilho/liquidctl/releases/download/v1.3.3/liquidctl-1.3.3-bin-windows-x86_64.zip).
 
-*pip* can be used to grab a [release from PyPI](https://pypi.org/project/liquidctl/#history).  For currently under development features, pip can also be used to install the latest snapshot of the official repository.
+Executables for previous releases can be found in the assets of the [Releases](https://github.com/jonasmalacofilho/liquidctl/releases) tab, and development builds can be found in the artifacts on the [AppVeyor runs](https://ci.appveyor.com/project/jonasmalacofilho/liquidctl/history).
 
-```
-# pip install liquidctl
-# pip install liquidctl==<version>
-# pip install git+https://github.com/jonasmalacofilho/liquidctl
-```
+Products that cannot use the generic Microsoft HID Driver require another driver that is compatible with libusb (see notes in the [Supported devices](#supported-devices) section).  In most cases Microsoft WinUSB is recommended, which can be easily set up for a device with [Zadig](https://zadig.akeo.ie/).¹
 
-_Note: a virtual environment can be used to avoid installing the package globally._
+The pre-built executables can be used as is by calling them from a Windows Command Prompt, Power Shell or other available terminal emulator.  Even so, most users will want to place the executable in a directory listed in [the `PATH` environment variable](https://en.wikipedia.org/wiki/PATH_(variable)), or change the variable so that becomes true; this allows omitting the full path and `.exe` extension when calling `liquidctl`.
 
-### Testing and developing new features
+_Alternatively to the pre-built executable,_ it is possible to install liquidctl from PyPI or directly from the source code repository.  Pre-build liquidctl executables for Windows already include Python and libusb, but when installing from PyPI or the sources both of these will need to be manually set up.
 
-Contributors to the project's code or documentation are encouraged to manually clone the repository.  pip can then be used to install liquidctl in editable/development mode.
+The libusb DLLs can be found in [libusb/releases](https://github.com/libusb/libusb/releases) (part of the `libusb-<version>.7z` files) and the appropriate (e.g. MS64) `.dll` and `.lib` files should be extracted to the system or python installation directory (e.g. `C:\Windows\System32` or `C:\Python36`).  Note that there is a [known issue in PyUSB](https://github.com/pyusb/pyusb/pull/227) that causes errors when the devices are released; the solution is to either manually patch PyUSB or stick to libusb 1.0.21.
 
+To install any release from PyPI, *pip* should be used:
 
 ```
-$ git clone https://github.com/jonasmalacofilho/liquidctl
-$ cd liquidctl
-# pip install --editable .
+> pip install liquidctl
+> pip install liquidctl==<version>
 ```
 
-_Note: a virtual environment can be used to avoid installing the package globally._
+For the latest changes and to contribute back to the project, it is best to clone the source code repository and install liquidctl from your local copy:
 
-### Additional requirements on Linux
+```
+> git clone https://github.com/jonasmalacofilho/liquidctl
+> cd liquidctl
+> python setup.py install
+```
 
-Installing cython-hidapi on Linux can require locally building some C extensions (automatically).  Both libusb-1.0 and libudev are needed for this, together with their corresponding development files.  You may also need development files for Python.
+_¹ See [How to use libusb under Windows](https://github.com/libusb/libusb/wiki/FAQ#how-to-use-libusb-under-windows) for more information._
 
-| Linux dependency | Arch Linux | Fedora | Ubuntu |
-| --- | --- | --- | --- |
-| python3 (dev) | python | python3-devel | python3-dev |
-| build tools | base-devel | "Development Tools" | build-essential |
-| libusb-1.0 (dev) | libusb-1.0 | libusbx-devel | libusb-1.0-0-dev |
-| libudev (dev) | (installed) | (installed) | libudev-dev |
 
-### Additional requirements on Windows
+## Installing on macOS
 
-Products that cannot use the generic Microsoft HID Driver require another driver that is compatible with libusb.  In most cases Microsoft's WinUSB driver is recommended, which can be easily configured for a device with [Zadig](https://zadig.akeo.ie/).¹
+liquidctl is available on Homebrew, and installing liquidctl using it is straightforward.
 
-Pre-build liquidctl executables for Windows already include libusb and HIDAPI, but when installing from PyPI or the sources you will need to manually set up the libusb runtime libraries.  You can get the DLLs from [libusb/releases](https://github.com/libusb/libusb/releases) (part of the `libusb-<version>.7z` files) and extract the appropriate (e.g. MS64) `.dll` and `.lib` files to your system or python installation directory (e.g. `C:\Windows\System32` or `C:\Python36`).  Note that there is a [known issue in PyUSB](https://github.com/pyusb/pyusb/pull/227) that causes errors when the devices are released; the solution is to either manually patch PyUSB or stick to libusb 1.0.21.
+```
+$ brew install liquidctl
+$ brew install liquidctl --HEAD
+```
 
-_¹ See [How to use libusb under Windows](https://github.com/libusb/libusb/wiki/FAQ#how-to-use-libusb-under-windows) for more information._
+By default the last stable version will be installed, but by passing `--HEAD` this can be changed to the last snapshot from this repository.  All dependencies are automatically resolved.
 
-### Additional requirements on Mac OS
+Another possibility is to install liquidctl from PyPI or directly from the source code repository, but in these cases Python 3 and libsub must be installed first; the recommended way is with `brew install python libusb`.
 
-A [homebrew tap](https://github.com/jonasmalacofilho/homebrew-liquidctl) is provided, and installing liquidctl using it is straightforward.
+To install any release from PyPI, *pip* should be used:
 
 ```
-$ brew tap jonasmalacofilho/liquidctl
-$ brew install liquidctl
+$ pip3 install liquidctl
+$ pip3 install liquidctl==<version>
 ```
 
-The formula can be used to install both the stable version or, by passing `--HEAD`, the latest snapshot from this repository.  All dependencies are be automatically resolved.
+To contribute back to the project, it is best to clone the source code repository and install liquidctl from your local copy:
+
+```
+$ git clone https://github.com/jonasmalacofilho/liquidctl
+$ cd liquidctl
+$ python3 setup.py install
+```
 
-If a different installation method is required, libsub must be installed first; the recommended way is with `brew install libusb`.
+_Note: installation into a virtual environment is recommended to avoid conflicts with Python modules installed with Homebrew.  The use of virtual environments is outside the scope of this document.  Their use will also restrict the availability of the liquidctl command to that virtual environment._
 
 
 ## Introducing the command-line interface
 
-The complete list of commands and options can be seen with `liquidctl --help`, but a good place to start is to ask liquidctl to list all recognized devices.
+The complete list of commands and options can be found in `liquidctl --help`, on in the man page, but the following topics cover the most common operations in the command-line interface.
+
+Brackets `[ ]`, parenthesis `( )`, less-than/greater-than `< >` and ellipsis `...` are used to describe optional, required, positional and repeating elements.  Example commands are prefixed with a number sign `#`, which also serves to indicate that on Linux root permissions might be required.
+
+The `--verbose` option will print some extra information, like automatically made adjustments to the user provided settings.  And if there is a problem, the `--debug` flag will make liquidctl output more information to help identify its cause; be sure to include this when opening a new issue.
+
+_Note: when debugging issues with PyUSB or libusb it can be useful to set the `PYUSB_DEBUG=debug` or/and `LIBUSB_DEBUG=4` environment variables._
+
+### Listing and selecting devices
+
+A good place to start is to ask liquidctl to list all recognized devices.
 
 ```
 # liquidctl list
+Device ID 0: NZXT Smart Device (V1)
+Device ID 1: NZXT Kraken X (X42, X52, X62 or X72)
 ```
 
 In case more than one supported device is found, the desired one can be selected with `--match <substring>`, where `<substring>` matches part of the desired device's description using a case insensitive comparison.
 
-More device properties can be show by passing `--verbose` to `liquidctl list`.  Any of these can also be used to select a particular product.  See `liquidctl --help` or the man page for more information.
+```
+# liquidctl --match kraken list
+Device ID 0: NZXT Kraken X (X42, X52, X62 or X72)
+```
 
-Finally, devices can also be selected with `--device <ID>`, but these are not guaranteed to remain stable and will vary with hardware changes, liquidctl updates or simply normal enumeration order variance.
+More device properties can be show by passing `--verbose` to `liquidctl list`.  Any of these can also be used to select a particular product.
+
+```
+# liquidctl --serial 1234567890 list
+Device ID 0: NZXT Kraken X (X42, X52, X62 or X72)
+```
+
+Ambiguities for any given filter can be solved with `--pick <number>`.  Devices can also be selected with `--device <ID>`, but these are not guaranteed to remain stable and will vary with hardware changes, liquidctl updates or simply normal variance in enumeration order.
+
+### Initializing and interacting with devices
 
 Devices will usually need to be initialized before they can be used, though each device has its own requirements and limitations.  This and other information specific to a particular device will appear on the documentation linked in the [supported devices](#supported-devices) section.
 
+Devices can be initialized individually or all at once.
+
 ```
-# liquidctl initialize
+# liquidctl [options] initialize [all]
 ```
 
 Most devices provide some status information, like fan speeds and liquid temperatures.  This can be queried for all devices or using the filtering methods mentioned before.
@@ -214,9 +261,25 @@
 # liquidctl [options] set <channel> color <mode> [<color>] ...
 ```
 
-Finally, the `--verbose` option will print some extra information, like automatically made adjustments to the user provided settings.  And if there is a problem, the `--debug` flag will make liquidctl output more information to help identify its cause; be sure to include this when opening a new issue.
+### Supported color specification formats
+
+When configuring lighting effects, colors can be specified in different representations and formats:
+
+ - as an implicit hexadecimal RGB triple: e.g. `ff7f3f`
+ - as an explicit RGB triple: e.g. `rgb(255, 127, 63)`
+ - as a HSV (hue‑saturation‑value) triple: e.g. `hsv(20, 75, 100)`
+    * hue ∊ [0, 360] (degrees); saturation, value ∊ [0, 100] (percent)
+    * note: this is sometimes called HSB (hue‑saturation‑brightness)
+  - as a HSL (hue‑saturation‑lightness) triple: e.g. `hsl(20, 100, 62)`
+    * hue ∊ [0, 360] (degrees); saturation, lightness ∊ [0, 100] (percent)
 
-_Note: when debugging issues with PyUSB or libusb it can be useful to set the `PYUSB_DEBUG` (`=debug`) or/and `LIBUSB_DEBUG` (`=4`) environment variables._
+Color arguments containing spaces, parenthesis or commas need to be quoted, as these characters can have special meaning on the command-line; the easiest way to do this on all supported platforms is with double quotes.
+
+```
+# liquidctl --match kraken set ring color fading "hsv(0,80,100)" "hsv(180,80,100)"
+```
+
+On Linux it is also possible to use single-quotes and `\(`, `\)`, `\ ` escape sequences.
 
 
 ## Automation and running at boot
@@ -255,7 +318,7 @@
 
 ### Set up Windows using Task Scheduler
 
-The configuration of devices can be automated by writing a batch file and setting up a new scheduled task for (every) log on.  The batch file can be really simple and consist of the invocations of liquidctl that would otherwise be done manually.
+The configuration of devices can be automated by writing a batch file and setting up a new task for (every) log on, using Windows Task Scheduler.  The batch file can be really simple and only needs to contain the invocations of liquidctl that would otherwise be done manually.
 
 ```batchfile
 liquidctl set pump speed 90
@@ -266,17 +329,13 @@
 
 Make sure that liquidctl is available in the context where the batch file will run: in short, `liquidctl --version` should work within a _normal_ Command Prompt window.
 
-When not using a pre-built liquidctl executable, try installing Python with the option to set the PATH variable enabled, or manually add the necessary folders to the PATH. Alternatively, if you're using Anaconda, try adding the following line to the beginning of the file:
-
-```batchfile
-call %homepath%\Anaconda3\Scripts\activate.bat
-```
+When not using a pre-built liquidctl executable, try installing Python with the option to set the PATH variable enabled, or manually add the necessary folders to the PATH.
 
-A slightly more complex example can be seen in [issue #14](https://github.com/jonasmalacofilho/liquidctl/issues/14#issuecomment-456519098) ("Can I autostart liquidctl on Windows?"), that uses the LEDs to convey progress or eventual errors.
+A slightly more complex example can be seen in [issue #14](https://github.com/jonasmalacofilho/liquidctl/issues/14#issuecomment-456519098) ("Can I autostart liquidctl on Windows?"), that uses the LEDs to convey progress or eventual errors.  Chris' guide on [Replacing NZXT’s CAM software on Windows for Kraken](https://codecalamity.com/replacing-nzxts-cam-software-on-windows-for-kraken/) is also a good read.
 
-Chris' guide on [Replacing NZXT’s CAM software on Windows for Kraken](https://codecalamity.com/replacing-nzxts-cam-software-on-windows-for-kraken/) goes into a lot more detail and is a good read.
+As an alternative to using Task Scheduler, the batch file can simply be placed in the startup folder; you can run `shell:startup` to [find out where that is](https://support.microsoft.com/en-us/help/4026268/windows-10-change-startup-apps).
 
-### Set up Mac OS using launchd
+### Set up macOS using launchd
 
 You can use a shell script and launchd to automatically configure your devices upon logging in.
 
